<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Tetrahedron.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>Tetrahedron.h</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#ifndef __TETRAHEDRON_HEADER__</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define __TETRAHEDRON_HEADER__</span>
00003 <span class="preprocessor"></span>
00004 <span class="preprocessor">#include &lt;iostream&gt;</span>
00005 <span class="preprocessor">#include &lt;fstream&gt;</span>
00006 <span class="preprocessor">#include &lt;vector&gt;</span>
00007 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00008 <span class="preprocessor">#include &lt;cstdarg&gt;</span>
00009 <span class="preprocessor">#include &lt;cassert&gt;</span>
00010 <span class="preprocessor">#include &lt;cmath&gt;</span>
00011 
00012 <span class="preprocessor">#include "Matrix.h"</span>
00013 
00014 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00015 <span class="keyword">class </span>Tetrahedron
00016 {
00017 <span class="keyword">public</span>:
00018         <span class="keywordtype">int</span> nDOF, nMPC, nDIM, nElements, nNodes, nDisp, nDOFPerNode,
00019                 nMaterials, nNodesPerElement, nProperties;
00020 
00021         <span class="keyword">struct </span>Element
00022         {
00023                 vector&lt;int&gt; Nodes;
00024                 <span class="keywordtype">int</span> Material;
00025                 T Temp;
00026                 Element():Nodes(4), Material(0) { Temp=T();};
00027         };
00028 
00029         <span class="keyword">struct </span>MPConstraint
00030         {
00031                 T b1, b2, b3;
00032                 <span class="keywordtype">int</span> i, j;
00033                 MPConstraint():i(0),j(0){ b1=b2=b3=T(); };
00034         };
00035 
00036         <span class="keyword">struct </span>Displacement
00037         {
00038                 <span class="keywordtype">int</span> index;
00039                 T value;
00040                 Displacement():index(0) { value = T(); };
00041         };
00042         
00043         <span class="keyword">struct </span>Node
00044         {
00045                 T x, y, z;
00046                 Node() { x = y = z = T(); };
00047         };
00048         
00049         <span class="keyword">struct </span>Material
00050         {
00051                 T E, Alpha, Nu;
00052                 Material() { E = Alpha = Nu = T(); };
00053         };
00054 
00055         <span class="keyword">typedef</span> Element ELEMENT;
00056         <span class="keyword">typedef</span> MPConstraint MPC;
00057         <span class="keyword">typedef</span> Displacement DISPLACEMENT;
00058         <span class="keyword">typedef</span> Node NODE;
00059         <span class="keyword">typedef</span> Material MATERIAL;
00060 
00061         vector&lt;NODE&gt; Nodes;
00062         vector&lt;ELEMENT&gt; Elements;
00063         vector&lt;MATERIAL&gt; Materials;
00064         vector&lt;T&gt; Forces;       <span class="comment">// Forces include reaction forces</span>
00065         vector&lt;DISPLACEMENT&gt; Loads; <span class="comment">// Loads is initial forces</span>
00066         vector&lt;DISPLACEMENT&gt; Displacements;
00067         vector&lt;MPC&gt; MPCons;
00068         vector&lt;T&gt; Reactions;
00069         
00070         Matrix&lt;T&gt; *Stresses;
00071         
00072         <span class="keywordtype">bool</span> isSolved;
00073 
00074         Tetrahedron (<span class="keywordtype">int</span> nen, <span class="keywordtype">int</span> ndim, <span class="keywordtype">int</span> ndn, <span class="keywordtype">int</span> npr);
00075         ~Tetrahedron ();
00076 
00077         <span class="comment">/* adds a node to the Nodes list at the specified index */</span>
00078         <span class="keywordtype">bool</span> AddNode (<span class="keywordtype">int</span> index, T x, T y, T z);
00079         <span class="comment">/* adds an element to the Elements list at the specified index */</span>
00080         <span class="keywordtype">bool</span> AddElement (<span class="keywordtype">int</span> index, <span class="keywordtype">int</span> Material, T temp, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
00081         <span class="comment">/* adds a material to the materials list at the specified index */</span>
00082         <span class="keywordtype">bool</span> AddMaterial (<span class="keywordtype">int</span> index, T E, T Nu, T Alpha);
00083         <span class="comment">/* adds a force at a dof, which is in the range of 0 and nDOF */</span>
00084         <span class="keywordtype">bool</span> AddForce (<span class="keywordtype">int</span> dof, T force);
00085         <span class="comment">/* adds a displacement at a dof */</span>
00086         <span class="keywordtype">bool</span> AddDisplacement (<span class="keywordtype">int</span> dof, T disp);
00087         <span class="comment">/* adds a multipoint constraint */</span>
00088         <span class="keywordtype">bool</span> AddMPCons (T b1, <span class="keywordtype">int</span> i, T b2, <span class="keywordtype">int</span> j, T b3);
00089         
00090         <span class="comment">/* removes a node at the specified index, from the list */</span>
00091         <span class="keywordtype">bool</span> RemoveNode (<span class="keywordtype">int</span> index);
00092         <span class="comment">/* removes an element at the specified index from the elements list */</span>
00093         <span class="keywordtype">bool</span> RemoveElement (<span class="keywordtype">int</span> index);
00094         <span class="comment">/* removes a material at index from the materials list */</span>
00095         <span class="keywordtype">bool</span> RemoveMaterial (<span class="keywordtype">int</span> index);
00096         <span class="comment">/* removes force at the specified dof */</span>
00097         <span class="keywordtype">bool</span> RemoveForce (<span class="keywordtype">int</span> dof);
00098         <span class="comment">/* removes a displacement at the specified dof */</span>
00099         <span class="keywordtype">bool</span> RemoveDisplacement (<span class="keywordtype">int</span> dof);
00100         <span class="comment">/* removes a multipoint constraint from the specified index */</span>
00101         <span class="keywordtype">bool</span> RemoveMPCons (<span class="keywordtype">int</span> index);
00102 
00103         <span class="comment">/* Solve the tetrahedron problem */</span>
00104         <span class="keywordtype">void</span> Solve ();
00105 
00106         <span class="comment">/* Write the end results to file */</span>
00107         <span class="keywordtype">bool</span> WriteResultsToFile (<span class="keyword">const</span> <span class="keywordtype">char</span>* fname);
00108 <span class="keyword">private</span>:
00109         T det;
00110 
00111         <span class="comment">/* calculates bandwidth of the matrix*/</span>
00112         <span class="keywordtype">int</span> CalculateBandwidth ();
00113         <span class="comment">/* Get stress-strain relation matrix */</span>
00114         Matrix&lt;T&gt;* GetDMatrix (<span class="keywordtype">int</span> element);
00115         <span class="comment">/* Get strain-displacement relation matrix */</span>
00116         Matrix&lt;T&gt;* GetBMatrix (<span class="keywordtype">int</span> element);
00117         <span class="comment">/* Get the temperature rise of an element as a vector */</span>
00118         Matrix&lt;T&gt;* GetTempLoadVector (<span class="keywordtype">int</span> element, Matrix&lt;T&gt; *db);
00119         <span class="comment">/* Get element stiffness matrix */</span>
00120         Matrix&lt;T&gt;* GetElementStiffnessMatrix (<span class="keywordtype">int</span> element, Matrix&lt;T&gt; *b, Matrix&lt;T&gt; *d);
00121         <span class="comment">/* Get global stiffness matrix, assembled from element stiffness matrices */</span>
00122         Matrix&lt;T&gt;* GetGlobalStiffnessMatrix ();
00123         <span class="comment">/* Get element stress vector */</span>
00124         Matrix&lt;T&gt;* GetElementStressVector (<span class="keywordtype">int</span> element);
00125         <span class="comment">/* Solve the stiffness matrix to determine displacements */</span>
00126         <span class="keywordtype">void</span> BandSolver(Matrix&lt;T&gt; *stiffness);
00127 };
00128 
00130 <span class="comment">//    METHOD IMPLEMENTATION BEGINS</span>
00131 
00132 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00133 Tetrahedron&lt;T&gt;::Tetrahedron (<span class="keywordtype">int</span> nen, <span class="keywordtype">int</span> ndim, <span class="keywordtype">int</span> ndn, <span class="keywordtype">int</span> npr)
00134                                   :Nodes(), Elements(), Materials(), Forces(),
00135                                   Displacements(), MPCons(), Reactions(), Stresses()
00136 {
00137         <span class="comment">/* initialize all of them to zero */</span>
00138         nNodes = nElements = nDisp = nMaterials = nMPC = 0;
00139         
00140         nNodesPerElement = nen;
00141         nDIM = ndim;
00142         nDOFPerNode = ndn;
00143         nProperties = npr;
00144         
00145         Stresses = NULL;
00146         
00147         <span class="comment">/* Used to check if the problem is solved or not */</span>
00148         isSolved = <span class="keyword">false</span>;
00149 
00150         det = 0;
00151 }
00152 
00153 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00154 Tetrahedron&lt;T&gt;::~Tetrahedron()
00155 {
00156         <span class="keywordflow">if</span> (Stresses != NULL)
00157                 delete Stresses;
00158         Stresses = NULL;
00159 }
00160 
00161 template&lt;class T&gt;
00162 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::AddNode (<span class="keywordtype">int</span> index, T x, T y, T z)
00163 {
00164         DBG_MSG(<span class="stringliteral">"AddNode Entered."</span>);
00165         
00166         NODE n;
00167         
00168         n.x = x;
00169         n.y = y;
00170         n.z = z;
00171         
00172         <span class="comment">/* if the index is greater than the number of nodes,</span>
00173 <span class="comment">        then resize the Nodes vector, and then insert */</span>
00174         <span class="keywordflow">if</span> ( index &gt;= nNodes)
00175         {
00176                 nNodes = index;
00177                 Nodes.resize (index+1);
00178         }
00179         
00180         Nodes[index] = n;
00181         
00182         <span class="comment">/* nDOF is dependent on nNodes, therefore as the number of</span>
00183 <span class="comment">        nodes changes, we have to change the value of nDOF. As Forces</span>
00184 <span class="comment">        vector must be of nDOF size, we must resize it to new nDOF size */</span>
00185         nDOF = nNodes * nDOFPerNode;
00186         Forces.resize (nDOF);
00187         
00188         DBG_MSG(<span class="stringliteral">"AddNode Leaving."</span>);
00189         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00190 }
00191 
00192 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00193 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::AddElement (<span class="keywordtype">int</span> index, <span class="keywordtype">int</span> Material, T Temp, 
00194                                                         <span class="keywordtype">int</span> n1, <span class="keywordtype">int</span> n2, <span class="keywordtype">int</span> n3, <span class="keywordtype">int</span> n4)
00195 {
00196         DBG_MSG(<span class="stringliteral">"AddElement Entered."</span>);
00197         
00198         ELEMENT e;
00199 
00200         e.Material = Material;
00201         e.Temp = Temp;
00202         e.Nodes[0] = n1;
00203         e.Nodes[1] = n2;
00204         e.Nodes[2] = n3;
00205         e.Nodes[3] = n4;
00206         
00207         <span class="comment">/* same as for nodes, check if index is more than</span>
00208 <span class="comment">        number of elements. If yes, then resize the Elements</span>
00209 <span class="comment">        vector */</span>
00210         <span class="keywordflow">if</span> (index &gt;= nElements) 
00211         {
00212                 nElements = index;
00213                 Elements.resize (index+1);
00214         }
00215         
00216         Elements[index] = e;
00217         
00218         DBG_MSG(<span class="stringliteral">"AddElement Leaving."</span>); 
00219         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00220 }
00221 
00222 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00223 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::AddMaterial (<span class="keywordtype">int</span> index, T E, T Nu, T Alpha)
00224 {
00225         DBG_MSG(<span class="stringliteral">"AddMaterial Entered."</span>);
00226         
00227         MATERIAL m;
00228         
00229         m.E = E;
00230         m.Alpha = Alpha;
00231         m.Nu = Nu;
00232         
00233         <span class="comment">/* similar to elements and nodes vector */</span>
00234         <span class="keywordflow">if</span> ( index &gt;= nMaterials)
00235         {
00236                 nMaterials = index;
00237                 Materials.resize (index+1);
00238         }
00239         
00240         Materials[index] = m;
00241         
00242         DBG_MSG(<span class="stringliteral">"AddMaterial Leaving."</span>);
00243         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00244 }
00245 
00246 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00247 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::AddForce (<span class="keywordtype">int</span> dof, T force)
00248 {
00249         DBG_MSG(<span class="stringliteral">"AddForce Entered."</span>);
00250         
00251         <span class="comment">/* Because the elements in forces vector is initialized</span>
00252 <span class="comment">        to zero, we just need to modify the Force at a particular</span>
00253 <span class="comment">        dof without worrying about the size */</span>
00254         <span class="keywordflow">if</span> (dof &gt;= 0 &amp;&amp; dof &lt; nDOF)
00255         {
00256                 Forces[dof] = force;
00257                 DISPLACEMENT d;
00258                 d.index = dof;
00259                 d.value = force;
00260                 Loads.push_back (d);
00261         }
00262         <span class="keywordflow">else</span> 
00263                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00264         
00265         DBG_MSG(<span class="stringliteral">"AddForce Leaving."</span>);
00266         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00267 }
00268 
00269 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00270 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::AddDisplacement (<span class="keywordtype">int</span> dof, T disp)
00271 {
00272         DBG_MSG(<span class="stringliteral">"AddDisplacement Entered."</span>);
00273         
00274         <span class="comment">/* check if dof specified is with in range</span>
00275 <span class="comment">        if yes, then simply push the new Displacement</span>
00276 <span class="comment">        into Displacements vector */</span>
00277         <span class="keywordflow">if</span> (dof &gt;= 0 &amp;&amp; dof &lt;= nDOF)
00278         {
00279                 DISPLACEMENT d;
00280                 d.index = dof;
00281                 d.value = disp;
00282 
00283                 Displacements.push_back (d);
00284                 <span class="comment">/* increment the nDisp counter */</span>
00285                 nDisp++;
00286                 
00287                 DBG_MSG(<span class="stringliteral">"AddDisplacement Leaving."</span>);
00288                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00289         }
00290         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00291 }
00292 
00293 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00294 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::AddMPCons (T b1, <span class="keywordtype">int</span> i, T b2, <span class="keywordtype">int</span> j, T b3)
00295 {
00296         DBG_MSG(<span class="stringliteral">"AddMPCons Entered."</span>);
00297         
00298         <span class="comment">/* similar to Displacement */</span>
00299         <span class="keywordflow">if</span> (i &lt;= nDOF &amp;&amp; j &lt;= nDOF)
00300         {
00301                 MPC mpc;
00302                 mpc.b1 = b1;
00303                 mpc.b2 = b2;
00304                 mpc.b3 = b3;
00305                 mpc.i = i;
00306                 mpc.j = j;
00307                 MPCons.push_back (mpc);
00308                 nMPC++;
00309                 
00310                 DBG_MSG(<span class="stringliteral">"AddMPCons Leaving."</span>);
00311                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00312         }
00313 
00314         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00315 }
00316 
00317 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00318 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::RemoveNode (<span class="keywordtype">int</span> index)
00319 {
00320         <span class="keywordflow">if</span> (index &gt; 0 &amp;&amp; index &lt;= nNodes)
00321         {
00322                 <span class="comment">/* check if this node is part of any element */</span>
00323                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i &lt;= nElements; i++)
00324                 {
00325                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nNodesPerElement; j++)
00326                         {
00327                                 <span class="keywordflow">if</span> (Elements[i].Nodes[j] == index)
00328                                         return false;
00329                         }
00330                 }
00331                 
00332                 <span class="comment">/* check if dof of this node has any force acting */</span>
00333                 for (<span class="keywordtype">int</span> i = 0; i &lt; nDOFPerNode; i++)
00334                 {
00335                         <span class="keywordflow">if</span> (Forces[index*nDOFPerNode + i] &gt; 0.0)
00336                                 return false;
00337                 }
00338                 
00339                 <span class="comment">/* check if a displacement boundary coundition has been</span>
00340 <span class="comment">                imposed on this node */</span>
00341                 <span class="keywordtype">int</span> temp;
00342                 for (<span class="keywordtype">int</span> i = 0; i &lt; nDisp; i++)
00343                 {
00344                         temp = (index-1) * nDOFPerNode;
00345                         <span class="keywordflow">if</span> (Displacements[i].index &gt;= temp &amp;&amp; 
00346                                 Displacements[i].index &lt; (temp+nDOFPerNode))
00347                                 return false;
00348                 }
00349                 
00350                 <span class="comment">/* no force, element, disp is dependent on this</span>
00351 <span class="comment">                node, so we can safely delete this */</span>
00352                 Nodes.erase (Nodes.begin() + index);
00353                 nNodes--;
00354                 
00355                 <span class="comment">/* make elements point to the correct node numbers</span>
00356 <span class="comment">                after a node is removed */</span>
00357                 for (<span class="keywordtype">int</span> i = 1; i &lt;= nElements; i++)
00358                 {
00359                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nNodesPerElement; j++)
00360                                 if (Elements[i].Nodes[j] &gt; index)
00361                                         Elements[i].Nodes[j]--;
00362                 }
00363                 
00364                 <span class="comment">/* when a node is deleted, the next node will</span>
00365 <span class="comment">                be in the index*nDOFPerNode position */</span>
00366                 for (<span class="keywordtype">int</span> i = 0; i &lt; nDOFPerNode; i++)
00367                         Forces.erase (Forces.begin() + ((index-1) * nDOFPerNode));
00368                 nDOF -= nDOFPerNode;
00369                 
00370                 <span class="comment">/* any displacement dof's must be made to point to</span>
00371 <span class="comment">                right node */</span>
00372                 for (<span class="keywordtype">int</span> i = 0; i &lt; nDisp; i++)
00373                         if (Displacements[i].index &gt; index)
00374                                 Displacements[i].index -= nDOFPerNode;
00375 
00376                 return true;
00377         }
00378         return false;
00379 }
00380 
00381 template&lt;class T&gt;
00382 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::RemoveElement (<span class="keywordtype">int</span> index)
00383 {
00384         <span class="comment">/* check if index is in range */</span>
00385         <span class="keywordflow">if</span> (index &gt; 0 &amp;&amp; index &lt;= nElements)
00386         {
00387                 <span class="comment">/* simply erase the element. there are no</span>
00388 <span class="comment">                dependencies to worry about */</span>
00389                 Elements.erase (Elements.begin() + index);
00390                 nElements--;
00391                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00392         }
00393         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00394 }
00395 
00396 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00397 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::RemoveMaterial (<span class="keywordtype">int</span> index)
00398 {
00399         <span class="keywordflow">if</span> (index &gt; 0 &amp;&amp; index &lt;= nMaterials)
00400         {
00401                 <span class="comment">/* check if any element uses this material */</span>
00402                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; nElements; i++)
00403                 {
00404                         <span class="keywordflow">if</span> (Elements[i].Material == index)
00405                                 return false;
00406                 }
00407                 <span class="comment">/* no element uses this material, so</span>
00408 <span class="comment">                we can safely delete this material */</span>
00409                 Materials.erase (Materials.begin() + index);
00410                 nMaterials--;
00411                 
00412                 <span class="comment">/* when a material is deleted, the next materials</span>
00413 <span class="comment">                index will be decreased by 1. Therefore, make the</span>
00414 <span class="comment">                Elements material index to point to the right material */</span>
00415                 for (<span class="keywordtype">int</span> i = 1; i &lt; nElements; i++)
00416                 {
00417                         <span class="keywordflow">if</span> (Elements[i].Material &gt; index)
00418                                 Elements[i].Material--;
00419                 }
00420                 return true;
00421         }
00422         return false;
00423 }
00424 
00425 template&lt;class T&gt;
00426 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::RemoveForce (<span class="keywordtype">int</span> dof)
00427 {
00428         <span class="comment">/* reinitialize the force to default force */</span>
00429         <span class="keywordflow">if</span> (dof &gt; 0 &amp;&amp; dof &lt; nDOF)
00430         {
00431                 Forces[dof] = T();
00432                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00433         }
00434         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00435 }
00436 
00437 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00438 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::RemoveDisplacement (<span class="keywordtype">int</span> index)
00439 {
00440         <span class="keywordflow">if</span> (index &gt;= 0 &amp;&amp; index &lt; nDisp)
00441         {
00442                 <span class="comment">/* remove the displacement without worrying about</span>
00443 <span class="comment">                any dependencies */</span>
00444                 Displacements.erase (Displacements.begin() + index);
00445                 nDisp--;
00446                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00447         }
00448         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00449 }
00450 
00451 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00452 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::RemoveMPCons (<span class="keywordtype">int</span> index)
00453 {
00454         <span class="keywordflow">if</span> (index &gt; 0 &amp;&amp; index &lt; nMPC)
00455         {
00456                 <span class="comment">/* remove the multipoint constraint */</span>
00457                 MPCons.erase (MPCons.begin() + index);
00458                 nMPC--;
00459                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00460         }
00461         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00462 }
00463 
00464 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00465 <span class="keywordtype">int</span> Tetrahedron&lt;T&gt;::CalculateBandwidth ()
00466 {
00467         DBG_MSG(<span class="stringliteral">"Entered CalculateBandwidth."</span>);
00468 
00469         <span class="keywordtype">int</span> bandwidth = 0, nmax, nmin, n;
00470         <span class="comment">/* find the maximum difference between dof indices</span>
00471 <span class="comment">        in a particular element and use it as bandwidth */</span>
00472         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nElements; i++) 
00473         {
00474                 nmin = Elements[i].Nodes[0];
00475                 nmax = nmin;
00476                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nNodesPerElement; j++) 
00477                 {
00478                         n = Elements[i].Nodes[j];
00479                         <span class="keywordflow">if</span> (nmin &gt; n)
00480                                 nmin = n;
00481                         if (nmax &lt; n)
00482                                 nmax = n;
00483                 }  
00484                 n = nDOFPerNode * (nmax - nmin + 1);
00485                 if (bandwidth &lt; n)
00486                         bandwidth = n;
00487         }
00488         <span class="comment">/* modify bandwidth to take care of Multipoint constraints */</span>
00489         for (<span class="keywordtype">int</span> i = 0; i &lt; nMPC; i++) 
00490         {
00491                 n = abs(MPCons[i].i - MPCons[i].j) + 1;
00492                 <span class="keywordflow">if</span> (bandwidth &lt; n)
00493                         bandwidth = n;
00494         }
00495         
00496         DBG_MSG("Leaving CalculateBandwidth.");
00497         return bandwidth;
00498 }
00499 
00500 template&lt;class T&gt;
00501 Matrix&lt;T&gt;* Tetrahedron&lt;T&gt;::GetDMatrix (<span class="keywordtype">int</span> element)
00502 {
00503         DBG_MSG(<span class="stringliteral">"Entered GetDMatrix."</span>);
00504 
00505         <span class="comment">/* This function is simply assigning the elements of</span>
00506 <span class="comment">        D matrix with correct values computed using stress-strain</span>
00507 <span class="comment">        relation matrix */</span>
00508 
00509         Matrix&lt;T&gt; *d;
00510         <span class="keywordflow">try</span> {
00511                  d = <span class="keyword">new</span> Matrix&lt;T&gt;(6,6);
00512         } <span class="keywordflow">catch</span> (bad_alloc) {
00513                 ERR_MSG(<span class="stringliteral">"Memory allocation error"</span>);
00514                 exit (1);
00515         }
00516 
00517         T E, Nu, Alpha, c1, c2, c3, c4;
00518         E = Materials[Elements[element].Material].E;
00519         Nu = Materials[Elements[element].Material].Nu;
00520         Alpha = Materials[Elements[element].Material].Alpha;
00521 
00522         c4 = E/( (1+Nu) * (1-2*Nu) );
00523         c1 = c4 * (1-Nu);
00524         c2 = c4 * Nu;
00525         c3 = 0.5 * E/(1+Nu);
00526 
00527         (*d)(0,0) = c1;
00528         (*d)(0,1) = c2;
00529         (*d)(0,2) = c2;
00530         (*d)(1,0) = c2;
00531         (*d)(1,1) = c1;
00532         (*d)(1,2) = c2;
00533         (*d)(2,0) = c2;
00534         (*d)(2,1) = c2;
00535         (*d)(2,2) = c1;
00536         (*d)(3,3) = c3;
00537         (*d)(4,4) = c3;
00538         (*d)(5,5) = c3;
00539 
00540         DBG_MSG(<span class="stringliteral">"Leaving GetDMatrix."</span>);
00541         <span class="keywordflow">return</span> d;
00542 }
00543 
00544 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00545 Matrix&lt;T&gt;* Tetrahedron&lt;T&gt;::GetBMatrix (<span class="keywordtype">int</span> element)
00546 {
00547         DBG_MSG(<span class="stringliteral">"Entered GetBMatrix."</span>);
00548 
00549         <span class="comment">/* This function is simply assigning the elements of</span>
00550 <span class="comment">        B matrix with correct values computed using strain-displacement</span>
00551 <span class="comment">        relation matrix */</span>
00552 
00553         Matrix&lt;T&gt; *b = <span class="keyword">new</span> Matrix&lt;T&gt;(6,12);
00554         <span class="keywordtype">int</span> n1, n2, n3, n4;
00555         T x14, x24, x34, y14, y24, y34, z14, z24, z34, 
00556                  a11, a21, a31, a12, a22, a32, a13, a23, a33;
00557         
00558         n1 = Elements[element].Nodes[0];
00559         n2 = Elements[element].Nodes[1];
00560         n3 = Elements[element].Nodes[2];
00561         n4 = Elements[element].Nodes[3];
00562 
00563         x14 = Nodes[n1].x - Nodes[n4].x;
00564         x24 = Nodes[n2].x - Nodes[n4].x;
00565         x34 = Nodes[n3].x - Nodes[n4].x;
00566         
00567         y14 = Nodes[n1].y - Nodes[n4].y;
00568         y24 = Nodes[n2].y - Nodes[n4].y;
00569         y34 = Nodes[n3].y - Nodes[n4].y;
00570         
00571         z14 = Nodes[n1].z - Nodes[n4].z;
00572         z24 = Nodes[n2].z - Nodes[n4].z;
00573         z34 = Nodes[n3].z - Nodes[n4].z;
00574         
00575         det = (x14 * (y24 * z34 - z24 * y34)) + 
00576                 (y14 * (z24 * x34 - x24 * z34)) + 
00577                 (z14 * (x24 * y34 - y24 * x34));
00578 
00579         a11 = (y24 * z34 - z24 * y34) / det;
00580         a21 = (z24 * x34 - x24 * z34) / det;
00581         a31 = (x24 * y34 - y24 * x34) / det;
00582         a12 = (y34 * z14 - z34 * y14) / det;
00583         a22 = (z34 * x14 - x34 * z14) / det;
00584         a32 = (x34 * y14 - y34 * x14) / det;
00585         a13 = (y14 * z24 - z14 * y24) / det;
00586         a23 = (z14 * x24 - x14 * z24) / det;
00587         a33 = (x14 * y24 - y14 * x24) / det;
00588 
00589         (*b)(0,0) = a11;
00590         (*b)(0,3) = a12;
00591         (*b)(0,6) = a13;
00592         (*b)(0,9) = -a11 - a12 - a13;
00593         (*b)(1,1) = a21;
00594         (*b)(1,4) = a22;
00595         (*b)(1,7) = a23;
00596         (*b)(1,10) = -a21 - a22 - a23;
00597         (*b)(2,2) = a31;
00598         (*b)(2,5) = a32;
00599         (*b)(2,8) = a33;
00600         (*b)(2,11) = -a31 - a32 - a33;
00601         (*b)(3,1) = a31;
00602         (*b)(3,2) = a21;
00603         (*b)(3,4) = a32;
00604         (*b)(3,5) = a22;
00605         (*b)(3,7) = a33;
00606         (*b)(3,8) = a23;
00607         (*b)(3,10) = (*b)(2,11);
00608         (*b)(3,11) = (*b)(1,10);
00609         (*b)(4,0) = a31;
00610         (*b)(4,2) = a11;
00611         (*b)(4,3) = a32;
00612         (*b)(4,5) = a12;
00613         (*b)(4,6) = a33;
00614         (*b)(4,8) = a13;
00615         (*b)(4,9) = (*b)(2,11);
00616         (*b)(4,11) = (*b)(0,9);
00617         (*b)(5,0) = a21;
00618         (*b)(5,1) = a11;
00619         (*b)(5,3) = a22;
00620         (*b)(5,4) = a12;
00621         (*b)(5,6) = a23;
00622         (*b)(5,7) = a13;
00623         (*b)(5,9) = (*b)(1,10);
00624         (*b)(5,10) = (*b)(0,9);
00625 
00626         DBG_MSG(<span class="stringliteral">"Leaving GetBMatrix."</span>);
00627         <span class="keywordflow">return</span> b;
00628 }
00629 
00630 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00631 Matrix&lt;T&gt;* Tetrahedron&lt;T&gt;::GetTempLoadVector (<span class="keywordtype">int</span> element, Matrix&lt;T&gt; *db)
00632 {
00633         DBG_MSG(<span class="stringliteral">"Entered GetTempLoadVector."</span>);
00634 
00635         Matrix&lt;T&gt; *tl;
00636         <span class="keywordflow">try</span> {
00637                 tl = <span class="keyword">new</span> Matrix&lt;T&gt;(1,12);
00638         } <span class="keywordflow">catch</span> (bad_alloc) {
00639                 ERR_MSG(<span class="stringliteral">"Memory allocation error."</span>);
00640                 exit (1);
00641         }
00642         
00643         T c , Alpha = Materials[Elements[element].Material].Alpha;
00644         c = Alpha * Elements[element].Temp;
00645         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 12; i++) 
00646         {
00647                 (*tl)(0,i) = c * fabs(det) * 
00648                                 ((*db)(0,i) + (*db)(1,i) + (*db)(2,i)) / 6;
00649         }
00650 
00651         DBG_MSG(<span class="stringliteral">"Leaving GetTempLoadVector."</span>);
00652         <span class="keywordflow">return</span> tl;
00653 }
00654 
00655 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00656 Matrix&lt;T&gt;* Tetrahedron&lt;T&gt;::GetElementStiffnessMatrix 
00657                                         (<span class="keywordtype">int</span> index, Matrix&lt;T&gt; *b, Matrix&lt;T&gt; *db)
00658 {
00659         DBG_MSG(<span class="stringliteral">"Entered GetElementStiffnessMatrix."</span>);
00660 
00661         Matrix&lt;T&gt; *stiffness;
00662         <span class="keywordflow">try</span> {
00663                 stiffness = <span class="keyword">new</span> Matrix&lt;T&gt; (12,12);
00664         } <span class="keywordflow">catch</span> (bad_alloc) {
00665                 ERR_MSG(<span class="stringliteral">"Memory allocation error."</span>);
00666                 exit (1);
00667         }
00668         
00669         <span class="comment">/* This is just calculating B'DB = Btranspose * DB */</span>
00670         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 12; i++) 
00671         {
00672                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 12; j++) 
00673                 {
00674                         (*stiffness)(i,j) = 0.;
00675                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; 6; k++) 
00676                         {
00677                                 (*stiffness)(i,j) = (*stiffness)(i,j) + 
00678                                                         fabs(det) * (*b)(k,i) * (*db)(k,j) / 6;
00679                         }
00680                 }
00681         }
00682 
00683         DBG_MSG(<span class="stringliteral">"Leaving GetElementStiffnessMatrix."</span>);
00684         <span class="keywordflow">return</span> stiffness;
00685 }
00686 
00687 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00688 Matrix&lt;T&gt;* Tetrahedron&lt;T&gt;::GetGlobalStiffnessMatrix ()
00689 {
00690         DBG_MSG(<span class="stringliteral">"Entered GetGlobalStiffnessMatrix."</span>);
00691 
00692         Matrix&lt;T&gt; *d, *b, *db, *se, *result;
00693         Matrix&lt;T&gt; *tl;
00694         <span class="keywordtype">int</span> bandwidth, i, j;
00695 
00696         bandwidth = CalculateBandwidth ();
00697 
00698         <span class="keywordflow">try</span> {
00699                 result = <span class="keyword">new</span> Matrix&lt;T&gt; (nDOF, bandwidth);
00700         } <span class="keywordflow">catch</span> (bad_alloc) {
00701                 ERR_MSG(<span class="stringliteral">"Memory allocation error."</span>);
00702                 exit (1);
00703         }
00704 
00705         <span class="comment">/* calculating the element stiffness matrix of each element</span>
00706 <span class="comment">        and then assembling them into global stiffness matrix */</span>
00707         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 1; n &lt;= nElements; n++)
00708         {
00709                 d = GetDMatrix (n);
00710                 b = GetBMatrix (n);
00711                 db = Multiply(d,b);
00712                 se = GetElementStiffnessMatrix (n, b, db);
00713                 tl = GetTempLoadVector (n, db);
00714                 
00715                 DBG_MSG(<span class="stringliteral">"Reached GetGlobalStiffnessMatrix."</span>);
00716                 
00717                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; nNodesPerElement; ii++)
00718                 {
00719                         <span class="keywordtype">int</span> nrt = nDOFPerNode * (Elements[n].Nodes[ii]-1);
00720                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> it = 0; it &lt; nDOFPerNode; it++) 
00721                         {
00722                                 <span class="keywordtype">int</span> nr = nrt + it;
00723                                 i = nDOFPerNode * ii + it;
00724                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jj = 0; jj &lt; nNodesPerElement; jj++) 
00725                                 {
00726                                         <span class="keywordtype">int</span> nct = nDOFPerNode * (Elements[n].Nodes[jj]-1);
00727                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jt = 0; jt &lt; nDOFPerNode; jt++) 
00728                                         {
00729                                                 j = nDOFPerNode * jj + jt;
00730                                                 <span class="keywordtype">int</span> nc = nct + jt - nr;
00731                                                 <span class="keywordflow">if</span> (nc &gt;= 0)
00732                                                         (*result)(nr,nc) = (*result)(nr,nc) 
00733                                                                                         + (*se)(i,j);
00734                                         }
00735                                 }
00736                                 Forces[nr] = Forces[nr] + (*tl)(0,i);
00737                         }
00738                 }
00739 
00740                 <span class="keyword">delete</span> d;
00741                 <span class="keyword">delete</span> b;
00742                 <span class="keyword">delete</span> db;
00743                 <span class="keyword">delete</span> se;
00744                 <span class="keyword">delete</span> tl;
00745         }
00746 
00747         DBG_MSG(<span class="stringliteral">"Leaving GetGlobalStiffnessMatrix."</span>);
00748         <span class="keywordflow">return</span> result;
00749 }
00750 
00751 
00752 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00753 Matrix&lt;T&gt;* Tetrahedron&lt;T&gt;::GetElementStressVector (<span class="keywordtype">int</span> element)
00754 {
00755         Matrix&lt;T&gt; *stress,*d, *b, *db;
00756         T ai1, ai21, ai22, ai2, ai31, ai32, ai3, c1, c2, c3, th, th2;
00757         T PI = 3.14159265;
00758         <span class="keywordtype">int</span> i,j,in,ii;
00759         T c,q[12];
00760 
00761         <span class="keywordflow">try</span>
00762         {
00763                 stress = <span class="keyword">new</span> Matrix&lt;T&gt;(1,9);
00764         }
00765         <span class="keywordflow">catch</span> (bad_alloc)
00766         {
00767                 ERR_MSG(<span class="stringliteral">"Memory allocation error."</span>);
00768                 exit (1);
00769         };
00770         
00771         d = GetDMatrix (element);
00772         b = GetBMatrix (element);
00773         
00774         db = Multiply (d,b);
00775         
00776         <span class="comment">/* --- stress evaluation (element nodal displacements stored in q() --- */</span>
00777         <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
00778                 in = 3 * (Elements[element].Nodes[i] - 1);
00779                 ii = 3 * i;
00780                 <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) 
00781                 {
00782                         q[ii + j] = Forces[in + j];
00783                 }
00784         }
00785                 
00786         c1 = Materials[Elements[element].Material].Alpha * Elements[element-1].Temp;
00787         
00788         <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) 
00789         {
00790                 c = T();
00791                 <span class="keywordflow">for</span> (j = 0; j &lt; 12; j++)
00792                 {
00793                         c = c + (*db)(i,j) * q[j];
00794                 }
00795                 (*stress)(0,i) = c - c1 * ((*d)(i,0) + (*d)(i,1) + (*d)(i,2));
00796         }
00797         
00798         <span class="comment">/* calculating principle stresses from the normal and shear stresses */</span>
00799         ai1 = (*stress)(0,0) + (*stress)(0,1) + (*stress)(0,2);
00800         
00801         ai21 = (*stress)(0,0) * (*stress)(0,1) + (*stress)(0,1) * (*stress)(0,2) + 
00802                         (*stress)(0,2) * (*stress)(0,0);
00803         ai22 = (*stress)(0,3) * (*stress)(0,3) + (*stress)(0,4) * (*stress)(0,4) + 
00804                         (*stress)(0,5) * (*stress)(0,5);
00805         ai2 = ai21 - ai22;
00806         
00807         ai31 = (*stress)(0,0) * (*stress)(0,1) * (*stress)(0,2) + 
00808                         2 * (*stress)(0,3) * (*stress)(0,4) * (*stress)(0,5);
00809         ai32 = (*stress)(0,0) * (*stress)(0,3) * (*stress)(0,3) + 
00810                         (*stress)(0,1) * (*stress)(0,4) * (*stress)(0,4) + 
00811                         (*stress)(0,2) * (*stress)(0,5) * (*stress)(0,5);
00812         ai3 = ai31 - ai32;
00813 
00814         c1 = ai2 - ai1 * ai1 / 3;
00815         c2 = -2 * (ai1*ai1*ai1) / 27 + ai1 * ai2 / 3 - ai3;
00816         c3 = 2 * sqrt((<span class="keywordtype">double</span>) -c1 / 3);
00817 
00818         th = -3 * c2 / (c1 * c3);
00819         th2 = sqrt((<span class="keywordtype">double</span>) fabs(1 - th * th));
00820         <span class="keywordflow">if</span> (th == 0)
00821                 th = PI / 2;
00822         if (th &gt; 0)
00823                 th = atan((<span class="keywordtype">double</span>) th2 / th);
00824         if (th &lt; 0)
00825                 th = PI - atan((<span class="keywordtype">double</span>) th2 / th);
00826         th = th / 3;
00827 
00828         (*stress)(0,6) = ai1 / 3 + c3 * cos(th);
00829         (*stress)(0,7) = ai1 / 3 + c3 * cos(th + 2 * PI / 3);
00830         (*stress)(0,8) = ai1 / 3 + c3 * cos(th + 4 * PI / 3);
00831 
00832         return stress;
00833 }
00834 
00835 template&lt;class T&gt;
00836 <span class="keywordtype">void</span> Tetrahedron&lt;T&gt;::BandSolver (Matrix&lt;T&gt; *stiffness)
00837 {
00838         DBG_MSG(<span class="stringliteral">"Entered BandSolver."</span>);
00839 
00840         <span class="comment">/* Solves the KQ=F equation to find out displacements */</span>
00841         <span class="keywordtype">int</span> n1,k,nk,i,i1,j,j1,kk, nbw;
00842         T c1;
00843         <span class="comment">/* ----- band solver ----- */</span>
00844         n1 = nDOF - 1;
00845         nbw = stiffness-&gt;getColumns();
00846         <span class="comment">/* --- forward elimination --- */</span>
00847         <span class="keywordflow">for</span> (k = 1; k &lt;= n1; k++) 
00848         {
00849                 nk = nDOF - k + 1;
00850                 <span class="keywordflow">if</span> (nk &gt; nbw)
00851                         nk = nbw;
00852                 for (i = 2; i &lt;= nk; i++) 
00853                 {
00854                         c1 = (*stiffness)(k-1,i-1) / (*stiffness)(k-1,0);
00855                         i1 = k + i - 1;
00856                         <span class="keywordflow">for</span> (j = i; j &lt;= nk; j++) 
00857                         {
00858                                 j1 = j - i + 1;
00859                                 (*stiffness)(i1-1,j1-1) = (*stiffness)(i1-1,j1-1) - 
00860                                                         c1 * (*stiffness)(k-1,j-1);
00861                         }
00862                         Forces[i1-1] = Forces[i1-1] - c1 * Forces[k-1];
00863                 }
00864         }
00865         
00866         <span class="comment">/* --- back-substitution --- */</span>
00867         Forces[nDOF-1] = Forces[nDOF-1] / (*stiffness)(nDOF-1,0);
00868         <span class="keywordflow">for</span> (kk = 1; kk &lt;= n1;kk++) {
00869                 k = nDOF - kk;
00870                 c1 = 1 / (*stiffness)(k-1,0);
00871                 Forces[k-1] = c1 * Forces[k-1];
00872                 nk = nDOF - k + 1;
00873                 <span class="keywordflow">if</span> (nk &gt; nbw)
00874                 nk = nbw;
00875                 for (j = 2; j &lt;= nk; j++) 
00876                 {
00877                         Forces[k-1] = Forces[k-1] - c1 * (*stiffness)(k-1,j-1) * 
00878                                                                         Forces[k + j - 2];
00879                 }
00880         }
00881         DBG_MSG(<span class="stringliteral">"Leaving BandSolver."</span>);
00882 }
00883 
00884 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00885 <span class="keywordtype">void</span> Tetrahedron&lt;T&gt;::Solve ()
00886 {
00887         DBG_MSG(<span class="stringliteral">"Entered Solve."</span>);
00888         
00889         T penalparam = T();
00890         Matrix&lt;T&gt; *stiffness;
00891         
00892         stiffness = GetGlobalStiffnessMatrix ();
00893 
00894         <span class="comment">/* ----- decide penalty parameter cnst ----- */</span>
00895         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nDOF; i++) 
00896         {
00897                 <span class="keywordflow">if</span> (penalparam &lt; (*stiffness)(i,0))
00898                         penalparam = (*stiffness)(i,0);
00899         }
00900         penalparam = penalparam * 10000.0;
00901 
00902         <span class="keywordtype">int</span> k;
00903         <span class="comment">/* ----- modify for displacement boundary conditions ----- */</span>
00904         for (<span class="keywordtype">int</span> i = 0; i &lt; nDisp; i++)
00905         {
00906                 k = Displacements[i].index;
00907                 (*stiffness)(k-1,0) = (*stiffness)(k-1,0) + penalparam;
00908                 Forces[k-1] = Forces[k-1] + penalparam * Displacements[i].value;
00909         }
00910 
00911         <span class="keywordtype">int</span> i1, i2, n, m;
00912         <span class="comment">/* ----- modify for multipoint constraints ----- */</span>
00913         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nMPC; i++)
00914         {
00915                 i1 = MPCons[i].i-1;
00916                 i2 = MPCons[i].j-1;
00917                 (*stiffness)(i1,0) = (*stiffness)(i1,0) + 
00918                                                 (penalparam * MPCons[i].b1 * MPCons[i].b1);
00919                 (*stiffness)(i2,0) = (*stiffness)(i2,0) + 
00920                                                 (penalparam * MPCons[i].b2 * MPCons[i].b2);
00921                 n=i1;
00922                 <span class="keywordflow">if</span> (n &gt; i2)
00923                         n = i2;
00924                 m = abs(i2-i1);
00925                 (*stiffness)(n,m) = (*stiffness)(n,m) + 
00926                                                 (penalparam * MPCons[i].b1 * MPCons[i].b2);
00927                 Forces[i1] = Forces[i1] + (penalparam * MPCons[i].b1 * MPCons[i].b3);
00928                 Forces[i2] = Forces[i2] + (penalparam * MPCons[i].b2 * MPCons[i].b3);
00929         }
00930         
00931         BandSolver (stiffness);
00932 
00933         <span class="comment">/* Calculate reactions */</span>
00934         for (<span class="keywordtype">int</span> i = 0; i &lt; nDisp; i++) 
00935         {
00936                 Reactions.push_back(penalparam * (Displacements[i].value - 
00937                                                 Forces[Displacements[i].index-1]));
00938         }
00939         
00940         <span class="comment">/* -----  stress calculations ----- */</span>
00941         Stresses = <span class="keyword">new</span> Matrix&lt;T&gt;(nElements+1,9);
00942         <span class="keywordflow">for</span> (n = 1; n &lt;= nElements; n++) 
00943         {
00944                 Matrix&lt;T&gt; *s = GetElementStressVector (n);
00945                 
00946                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 9; j++)
00947                         (*Stresses)(n,j) = (*s)(0,j);
00948                 
00949                 <span class="keyword">delete</span> s;
00950         }
00951         
00952         isSolved = <span class="keyword">true</span>;
00953         
00954         DBG_MSG(<span class="stringliteral">"Leaving Solve."</span>);
00955 }
00956 
00957 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00958 <span class="keywordtype">bool</span> Tetrahedron&lt;T&gt;::WriteResultsToFile (<span class="keyword">const</span> <span class="keywordtype">char</span>* fname)
00959 {
00960         ofstream ofile (fname);
00961         <span class="keywordflow">if</span> (!ofile)
00962         {
00963                 ERR_MSG(<span class="stringliteral">"File open failed"</span>);
00964                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00965         }
00966 
00967         ofile &lt;&lt; endl &lt;&lt; <span class="stringliteral">"RESULTS"</span> &lt;&lt; endl;
00968         ofile &lt;&lt; <span class="stringliteral">"bandwidth = "</span> &lt;&lt; CalculateBandwidth() &lt;&lt; endl;
00969         ofile &lt;&lt; <span class="stringliteral">"node#     x-displ      y-displ      z-displ"</span> &lt;&lt; endl;
00970         <span class="comment">/* write displacements to file */</span>
00971         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nNodes; i++) 
00972         {
00973                 ofile &lt;&lt; i+1 &lt;&lt; Forces[3*i] &lt;&lt; Forces[3*i+1] &lt;&lt; Forces[3*i+2] &lt;&lt; endl;
00974         }
00975         
00976         <span class="comment">/* write reactions at different boundary conditions to file */</span>
00977         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nDisp; i++)
00978         {
00979                 ofile &lt;&lt; Displacements[i].index &lt;&lt; Reactions[i] &lt;&lt; endl;
00980         }
00981 
00982         <span class="comment">/* write stresses to file */</span>
00983         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nElements; i++)
00984         {
00985                 ofile &lt;&lt; <span class="stringliteral">"stresses in element no. "</span> &lt;&lt; i &lt;&lt; endl;
00986                 ofile &lt;&lt; <span class="stringliteral">"  normal stresses sx,sy,sz"</span> &lt;&lt; endl;
00987                 ofile &lt;&lt; <span class="stringliteral">"  "</span>&lt;&lt; (*Stresses)(i,0) &lt;&lt; <span class="stringliteral">"  "</span> 
00988                                 &lt;&lt; (*Stresses)(i,1) &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; (*Stresses)(i,2) &lt;&lt; endl;
00989                 ofile &lt;&lt; <span class="stringliteral">"  shear stresses tyz,txz,txy"</span> &lt;&lt; endl;
00990                 ofile &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; (*Stresses)(i,3) &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; (*Stresses)(i,4) &lt;&lt;
00991                                 <span class="stringliteral">"  "</span> &lt;&lt; (*Stresses)(i,5) &lt;&lt; endl;
00992                 ofile &lt;&lt; <span class="stringliteral">"  principal stresses"</span> &lt;&lt; endl;
00993                 ofile &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; (*Stresses)(i,6) &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; (*Stresses)(i,7)
00994                         &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; (*Stresses)(i,8) &lt;&lt; endl;
00995         }
00996         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00997 }
00998 
00999 <span class="comment">//    METHOD IMPLEMENTATION ENDS</span>
01001 <span class="comment"></span>
01002 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
01003 Tetrahedron&lt;T&gt;* CreateTetrahedronFromFile (<span class="keyword">const</span> <span class="keywordtype">char</span>* fname)
01004 {
01005         ifstream ifile;
01006         <span class="keywordtype">int</span> iTemp, nLoads, n;
01007         <span class="keywordtype">int</span> nNodes, nElements, nMaterials, nDIM, nNodesPerElement,
01008                 nDOFPerNode, nDisp, nMPC, nDOF, nProperties;
01009         <span class="keywordtype">char</span> dummy[81], title[81];
01010         T tTemp, tx, ty, tz;
01011 
01012         ifile.open(fname);
01013         <span class="keywordflow">if</span> (!ifile)
01014         {
01015                 ERR_MSG(<span class="stringliteral">"Cannot open output file."</span>);
01016                 exit (0);
01017         }
01018 
01019         ifile.getline (dummy,80);
01020         ifile.getline (title,80);
01021         ifile.getline (dummy,80);
01022         
01023         ifile &gt;&gt; nNodes &gt;&gt; nElements &gt;&gt; nMaterials &gt;&gt; nDIM &gt;&gt; nNodesPerElement 
01024                 &gt;&gt; nDOFPerNode; 
01025         ifile.get (); <span class="comment">// to ignore newline char</span>
01026         
01027         ifile.getline (dummy, 80);
01028         ifile &gt;&gt; nDisp &gt;&gt; nLoads &gt;&gt; nMPC;
01029         ifile.get (); <span class="comment">// to ignore newline char</span>
01030         
01031         nDOF = nNodes * nDOFPerNode;
01032         <span class="comment">/* material properties E, Nu, Alpha */</span>
01033         nProperties = 3;
01034 
01035         <span class="keywordflow">if</span> (nNodesPerElement != 4 || nDIM != 3 || nDOFPerNode != 3 || 
01036                                 nProperties != 3)
01037                 return NULL;
01038         
01039         Tetrahedron&lt;T&gt; *t;
01040         try {
01041                 t = <span class="keyword">new</span> Tetrahedron&lt;T&gt;(nNodesPerElement, nDIM, nDOFPerNode, nProperties);
01042         } <span class="keywordflow">catch</span> (bad_alloc) {
01043                 ERR_MSG(<span class="stringliteral">"Memory allocation error."</span>);
01044                 exit (1);
01045         }
01046 
01047         <span class="comment">/* ----- coordinates ----- */</span>
01048         ifile.getline (dummy,80);
01049         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nNodes; i++)
01050         {
01051                 ifile &gt;&gt; n;
01052                 ifile &gt;&gt; tx &gt;&gt; ty &gt;&gt; tz;
01053                 t-&gt;AddNode(n, tx, ty, tz);
01054                 
01055                 ifile.get (); <span class="comment">// to ignore new line char</span>
01056         }
01057 
01058         <span class="comment">/* ----- connectivity, material, temp-change ----- */</span>
01059         ifile.getline (dummy,80);
01060         <span class="keywordtype">int</span> n1, n2, n3, n4;
01061         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nElements; i++)
01062         {
01063                 ifile &gt;&gt; n;
01064                 ifile &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; n3 &gt;&gt; n4;
01065                 ifile &gt;&gt; iTemp;
01066                 ifile &gt;&gt; tTemp;
01067                 t-&gt;AddElement (n, iTemp, tTemp, n1, n2, n3, n4);
01068                 
01069                 ifile.get (); <span class="comment">// to ignore new line char</span>
01070         }
01071 
01072         <span class="comment">/* ----- displacement bc  ----- */</span>
01073         ifile.getline (dummy,80);
01074         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nDisp; i++) 
01075         {
01076                 ifile &gt;&gt; iTemp &gt;&gt; tTemp;
01077                 t-&gt;AddDisplacement (iTemp, tTemp);
01078                 
01079                 ifile.get (); <span class="comment">// to ignore newline char</span>
01080         }
01081 
01082         <span class="comment">/* ----- component loads ----- */</span>
01083         ifile.getline (dummy,80);
01084         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nLoads; i++) 
01085         {
01086                 ifile &gt;&gt; iTemp &gt;&gt; tTemp;
01087                 t-&gt;AddForce(iTemp-1,tTemp);
01088                 
01089                 ifile.get (); <span class="comment">// to ignore newline char</span>
01090         }
01091 
01092         <span class="comment">/* ----- material properties ----- */</span>
01093         ifile.getline (dummy,80);
01094         T E, Alpha, Nu;
01095         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nMaterials; i++)
01096         {
01097                 ifile &gt;&gt; iTemp;
01098                 <span class="keywordflow">if</span> (iTemp &gt; nMaterials) {
01099                         ERR_MSG(<span class="stringliteral">"Material index must be less than number of materials"</span>);
01100                         exit (1);
01101                 }
01102                 
01103                 ifile &gt;&gt; E &gt;&gt; Alpha &gt;&gt; Nu;
01104                 t-&gt;AddMaterial (iTemp, E, Alpha, Nu);
01105         }
01106 
01107         <span class="comment">/* ----- multipoint constraints ----- */</span>
01108         ifile.getline (dummy, 80);
01109         T b1, b2, b3;
01110         <span class="keywordtype">int</span> jTemp;
01111         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nMPC; i++)
01112         {
01113                 ifile &gt;&gt; b1 &gt;&gt; iTemp &gt;&gt; b2 &gt;&gt; jTemp &gt;&gt; b3;
01114                 t-&gt;AddMPCons (b1, iTemp, b2, jTemp, b3);
01115         }
01116 
01117         ifile.close ();
01118 
01119         <span class="keywordflow">return</span> t;
01120 }
01121 
01122 <span class="preprocessor">#endif </span><span class="comment">/* __TETRAHEDRON_HEADER__ */</span>
01123 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Mar 8 20:45:06 2006 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
