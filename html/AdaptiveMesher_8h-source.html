<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AdaptiveMesher.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>AdaptiveMesher.h</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#ifndef __ADAPTIVE_MESHER_HEADER__</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define __ADAPTIVE_MESHER_HEADER__</span>
00003 <span class="preprocessor"></span>
00005 <span class="comment">// Include files</span>
00006 
00007 <span class="preprocessor">#include &lt;vector&gt;</span>
00008 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00009 
00010 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00011 
00013 <span class="comment">// AdaptiveMesher class declaration begins</span>
00014 
00015 <span class="keyword">class </span>AdaptiveMesher
00016 {
00017 <span class="keyword">public</span>:
00018 
00019         <span class="keyword">struct </span>tagEdge;
00020 
00021         <span class="keyword">typedef</span> <span class="keyword">struct </span>tagEdge EDGE;
00022         <span class="keyword">typedef</span> <span class="keyword">struct </span>tagEdge* PEDGE;
00023         
00024         <span class="keyword">struct </span>tagNode {
00025                 REAL x, y, z;
00026                 vector&lt;PEDGE&gt; Edges;
00027         };
00028 
00029         <span class="keyword">typedef</span> <span class="keyword">struct </span>tagNode NODE;
00030         <span class="keyword">typedef</span> <span class="keyword">struct </span>tagNode* PNODE;
00031         
00032         <span class="keyword">struct </span>tagEdge {
00033                 NODE* Nodes[2];
00034                 <span class="keywordtype">bool</span> Refine;
00035         };
00036 
00037         <span class="keyword">struct </span>tagElement {
00038                 PNODE Nodes[4];
00039                 PEDGE Edges[6];
00040                 <span class="keywordtype">int</span> elmIndex;
00041         };
00042         
00043     <span class="keyword">typedef</span> <span class="keyword">struct </span>tagElement ELEMENT;
00044     <span class="keyword">typedef</span> <span class="keyword">struct </span>tagElement* PELEMENT;
00045 
00046         REAL MaxPropertyValue;
00047 
00048         
00049         AdaptiveMesher (Tetrahedron&lt;REAL&gt; *t);
00050         ~AdaptiveMesher ();
00051 
00052         <span class="comment">/* It implements the algorithm explained in</span>
00053 <span class="comment">        clearproc.png file */</span>
00054         <span class="keywordtype">void</span> Mesh ();
00055         Tetrahedron&lt;REAL&gt;* GetMeshedTetrahedron ();
00056 
00057 <span class="keyword">private</span>:
00058 
00059         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> EDGES_PER_ELEMENT = 6;
00060         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> NODES_PER_ELEMENT = 4;
00061 
00062         Tetrahedron&lt;REAL&gt; *tetra;       
00063 
00064         vector&lt;PNODE&gt; Nodes, MeshedNodes;
00065         vector&lt;PEDGE&gt; Edges, MeshedEdges;
00066         vector&lt;PELEMENT&gt; Elements, MeshedElements;
00067 
00068         <span class="comment">/* Form B-Rep model from the connectivity table */</span>
00069         <span class="keywordtype">void</span> FormBRepModel ();
00070         <span class="comment">/* Find the max value of the property choosen for</span>
00071 <span class="comment">         * checking the refinement of an element */</span>
00072         <span class="keywordtype">void</span> FindMaxPropertyValue ();
00073         <span class="comment">/* Mark elements for refinement */</span>
00074         <span class="keywordtype">void</span> MarkElements ();
00075         <span class="comment">/* Mesh elements marked for refinement */</span>
00076         <span class="keywordtype">void</span> MeshElements ();
00077         <span class="comment">/* Returns true if the element requires refinement */</span>
00078         <span class="keywordtype">bool</span> NeedsRefinement (PELEMENT elm);
00079         <span class="comment">/* Checks if two nodes are at the same point */</span>
00080         <span class="keywordtype">bool</span> isSameNode (PNODE node1, PNODE node2);
00081         <span class="comment">/* Checks if two edges are intersecting each other */</span>
00082         <span class="keywordtype">bool</span> isIntersectingEdge (PEDGE srcedge, PEDGE destedge);
00083         
00084         <span class="comment">/* Returns the mid node of an edge */</span>
00085         PNODE GetMidNode (vector&lt;PNODE&gt;&amp;, <span class="keyword">const</span> PEDGE&amp; edge);
00086         <span class="comment">/* Form a tetrahedron using the Beys Method */</span>
00087         PELEMENT FormTetrahedron (vector&lt;PELEMENT&gt;&amp;, vector&lt;PEDGE&gt;&amp;, <span class="keyword">const</span> PNODE);
00088         <span class="comment">/* Returns the index of the edge, formed between two</span>
00089 <span class="comment">         * nodes, within the edges vector */</span>
00090         <span class="keywordtype">int</span> GetEdgeIndex (<span class="keyword">const</span> vector&lt;PEDGE&gt;&amp;, PNODE, PNODE);
00091 
00092         <span class="comment">/* Returns the node pointer, which correctly points to</span>
00093 <span class="comment">         * node which can be used to form an edge, which does not</span>
00094 <span class="comment">         * intersect with any other edge */</span>
00095         PNODE GetCorrectNode (vector&lt;PEDGE&gt;&amp;, vector&lt;PNODE&gt;&amp;, PEDGE, PEDGE);
00096         <span class="comment">/* Create a Node at the 3D point and add to the vector</span>
00097 <span class="comment">         * based on the addToList value */</span>
00098         PNODE CreateTetraNode (vector&lt;PNODE&gt;&amp;, REAL x, REAL y, REAL z, <span class="keywordtype">bool</span> addToList = <span class="keyword">true</span>);
00099         <span class="comment">/* Create a Node at the same point as that of the node</span>
00100 <span class="comment">         * passed */</span>
00101         PNODE CreateTetraNode (vector&lt;PNODE&gt;&amp;, PNODE, <span class="keywordtype">bool</span> addToList = <span class="keyword">false</span>);
00102         <span class="comment">/* Create an edge between two nodes and add it into</span>
00103 <span class="comment">         * edges vector based on the addToList value */</span>
00104         PEDGE CreateTetraEdge (vector&lt;PEDGE&gt;&amp;, PNODE n1, PNODE n2, <span class="keywordtype">bool</span> addToList = <span class="keyword">true</span>);
00105         <span class="comment">/* Creata an edge between the same nodes that the edge</span>
00106 <span class="comment">         * passed exists between */</span>
00107         PEDGE CreateTetraEdge (vector&lt;PEDGE&gt;&amp; Edges, PEDGE edge);
00108         <span class="comment">/* Create edges between the nodes */</span>
00109         PEDGE* CreateEdgesFromNodes (vector&lt;PEDGE&gt;&amp;, PNODE* nodes);
00110         <span class="comment">/* Create an element from the nodes and edges, and add</span>
00111 <span class="comment">         * it into the elements vector based on the addToList</span>
00112 <span class="comment">         * value */</span>
00113         PELEMENT CreateTetraElement (vector&lt;PELEMENT&gt;&amp;, PNODE*, PEDGE*, <span class="keywordtype">bool</span> addToList = <span class="keyword">true</span>);
00114 };
00115 
00116 <span class="comment">// AdaptiveMesher class declaration ends</span>
00118 <span class="comment"></span>
00119 <span class="preprocessor">#endif </span><span class="comment">/* __ADAPTIVE_MESHER_HEADER__ */</span>
00120 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Mar 8 20:45:05 2006 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
